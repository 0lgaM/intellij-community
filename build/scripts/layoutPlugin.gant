/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import com.intellij.openapi.util.JDOMUtil
import com.intellij.openapi.util.Pair
import com.intellij.openapi.util.io.FileUtil
import com.intellij.openapi.util.text.StringUtil
import org.jetbrains.jps.devkit.builder.RuntimeModuleDescriptorData
import org.jetbrains.jps.devkit.builder.RuntimeModuleDescriptorsGenerator
import org.jetbrains.jps.devkit.model.JpsRuntimeResourceRoot
import org.jetbrains.jps.devkit.model.JpsRuntimeResourcesService
import org.jetbrains.jps.gant.LayoutInfo
import org.jetbrains.jps.model.ex.JpsElementBase
import org.jetbrains.jps.model.java.JavaModuleSourceRootTypes
import org.jetbrains.jps.model.java.JavaResourceRootType
import org.jetbrains.jps.model.java.JavaSourceRootType
import org.jetbrains.jps.model.java.JpsJavaExtensionService
import org.jetbrains.jps.model.library.JpsLibrary
import org.jetbrains.jps.model.library.JpsOrderRootType
import org.jetbrains.jps.model.module.JpsModule
import org.jetbrains.jps.util.JpsPathUtil
import org.jetbrains.platform.loader.repository.RuntimeModuleId

import static org.jetbrains.jps.devkit.builder.RuntimeModuleDescriptorsGenerator.getLibraryId

binding.setVariable("layoutPluginByRuntimeModules", { String mainModuleName ->
  def mainModule = findModule(mainModuleName)
  if (mainModule == null) {
    projectBuilder.error("Module '$mainModuleName' not found")
  }
  def pluginXml = findPluginXml(mainModule)
  def rootTag = JDOMUtil.load(pluginXml)
  List<Pair<JpsModule, String>> modulesWithScopes = []
  def libraryMap = getOrCreateLibraryMap()
  List<Pair<JpsLibrary, String>> librariesWithScopes = []
  rootTag.getChildren("modules").each {
    it.getChildren("module").each {
      def moduleName = it.getTextTrim()
      def scope = it.getAttributeValue("scope") ?: moduleName == mainModuleName ? "embedded" : "IDE"
      if (!moduleName.startsWith("lib.")) {
        modulesWithScopes.add(Pair.create(findModule(moduleName), scope))
      }
      else {
        def library = libraryMap[moduleName]
        if (library == null) {
          projectBuilder.error("Cannot find library ${moduleName} required to build '$mainModuleName' plugin")
        }
        librariesWithScopes.add(Pair.create(library, scope))
      }
    }
  }
  if (!modulesWithScopes.any { it.first.name == mainModuleName }) {
    modulesWithScopes.add(Pair.create(mainModule, "embedded"))
  }

  List<JpsRuntimeResourceRoot> runtimeResources = modulesWithScopes.collectMany {JpsRuntimeResourcesService.instance.getRoots(it.first)?.getRoots() ?: [] }

  def compatibilityMap = getOrCreateFileNameCompatibilityMap()[mainModuleName]
  String mainJarName = compatibilityMap?.jar ?: "${mainModuleName}.jar"
  def dirName = compatibilityMap?.dir ?: mainModuleName

  dir(dirName) {
    LayoutInfo layoutInfo = currentLayoutInfo
    def pluginTargetDir = "$layoutInfo.currentPath"
    dir("lib") {
      def embeddedModules = modulesWithScopes.findAll { it.second == "embedded" }.collect { it.first }
      def embeddedLibraries = librariesWithScopes.findAll { it.second == "embedded" }.collect {it.first}
      jar(mainJarName) {
        embeddedModules.each {
          noResources(it.name)
        }

        embeddedLibraries.collectMany {it.getFiles(JpsOrderRootType.COMPILED)}.each { File file ->
          zipfileset(src: file.absolutePath)
        }
      }
/*
      embeddedModules.each {
        registerModuleDescriptor(it, ["$pluginTargetDir/lib/$mainJarName", "$pluginTargetDir/lib/resources_en.jar"])
      }
*/
      embeddedLibraries.each {
        registerModuleDescriptor(getLibraryId(it), ["$pluginTargetDir/lib/$mainJarName"])
      }

      def ideModules = modulesWithScopes.findAll { it.second.contains("IDE") }.collect { it.first }
      ideModules.each { module ->
        jar([name: "${module.name}.jar", filesetmanifest: "merge"]) {
          noResources(module.name)
        }
//        registerModuleDescriptor(module, ["$pluginTargetDir/lib/${module.name}.jar", "$pluginTargetDir/lib/resources_en.jar"])
      }
      resources(ideModules.collect {it.name} + embeddedModules.collect {it.name})

      librariesWithScopes.findAll {it.second.contains("IDE")}.collect {it.first}.each { lib ->
        layoutLibrary(lib, "$pluginTargetDir/lib")
      }
      layoutInSubdir(modulesWithScopes, librariesWithScopes, "$pluginTargetDir/lib", "build", "jps")
      layoutInSubdir(modulesWithScopes, librariesWithScopes, "$pluginTargetDir/lib", "runtime", "rt")
    }
    layoutRuntimeResources(runtimeResources, pluginTargetDir)
  }
})

private void layoutRuntimeResources(List<JpsRuntimeResourceRoot> runtimeResources, String outputDir) {
  if (!runtimeResources.isEmpty()) {
    dir("res") {
      runtimeResources.each {
        File file = JpsPathUtil.urlToFile(it.url)
        String name = null
        if (file.isFile()) {
          fileset(file: file.absolutePath)
          name = file.name
        }
        else if (file.isDirectory()) {
          dir(it.name) {
            fileset(dir: file.absolutePath)
          }
          name = it.name
        }
        else {
          projectBuilder.error("Cannot find file ${file.absolutePath} for runtime resource $it.name")
        }
        registerModuleDescriptor(RuntimeModuleId.moduleResource(it.module.name, it.name), ["$outputDir/res/$name"])
      }
    }
  }
}

private boolean registerModuleDescriptor(JpsModule module, Collection<? extends CharSequence> paths) {
  getOrCreateRuntimeModuleDescriptorsList().add(RuntimeModuleDescriptorsGenerator.createModuleDescriptor(module, false, toFiles(paths)))
}

binding.setVariable("registerLibraryDescriptor", {RuntimeModuleId id, List<? extends CharSequence> paths ->
  registerModuleDescriptor(id, paths)
})

binding.setVariable("registerJarDirLibraryDescriptor", {RuntimeModuleId id, File jarDir, String outputDir ->
  registerModuleDescriptor(id, jarDir.list {d,name-> name.endsWith(".jar")}.collect {"$outputDir/$it"})
})

private boolean registerModuleDescriptor(RuntimeModuleId id, List<? extends CharSequence> paths) {
  getOrCreateRuntimeModuleDescriptorsList().add(new RuntimeModuleDescriptorData(id, toFiles(paths)))
}

private Map<String, Map<String, String>> getOrCreateFileNameCompatibilityMap() {
  String varName = "fileNameCompatibilityMap"
  if (!binding.hasVariable(varName)) {
    binding.setVariable(varName, new HashMap())
  }
  return (Map<String, Map<String, String>>) binding.getVariable(varName)
}

private List<RuntimeModuleDescriptorData> getOrCreateRuntimeModuleDescriptorsList() {
  String varName = "runtimeModuleDescriptorsList"
  if (!binding.hasVariable(varName)) {
    binding.setVariable(varName, new ArrayList())
  }
  return (List<RuntimeModuleDescriptorData>) binding.getVariable(varName)
}

binding.setVariable("copyPlatformLibraries", { String targetDirectory, Collection<String> platformModules, LayoutInfo layoutInfo ->
  def descriptors = getOrCreateRuntimeModuleDescriptorsList()
  def copiedLibrariesIds = descriptors.collect {it.moduleId}
  def libDir = new File(targetDirectory, "lib")
  def librariesCopiedToLibIds = descriptors.findAll {it.moduleRoots.any { FileUtil.isAncestor(libDir, it, true)}}.collect {it.moduleId}
  def notCopied = { JpsLibrary lib -> !copiedLibrariesIds.contains(getLibraryId(lib)) }
  def platformLibraries = getLibrariesFromDependencies(platformModules).findAll{!librariesCopiedToLibIds.contains(getLibraryId(it))}
  platformLibraries.findAll {copiedLibrariesIds.contains(getLibraryId(it))}.each {
    def libraryId = getLibraryId(it)
    projectBuilder.warning("Platform library ${libraryId} copied to plugin (${descriptors.findAll{it.moduleId == libraryId}.collectMany {it.moduleRoots}})")
  }
  def pluginLibraries = getLibrariesFromDependencies(layoutInfo.modules - platformModules).findAll(notCopied) - platformLibraries
  def modulePluginLibraries = pluginLibraries.findAll { ((JpsElementBase)it).getParent().getParent() instanceof JpsModule }
  modulePluginLibraries.each {
    projectBuilder.warning("Module-level library ${getLibraryId(it)} from plugin isn't included to its layout")
  }

  List<JpsRuntimeResourceRoot> runtimeResources = platformModules.collectMany {JpsRuntimeResourcesService.instance.getRoots(findModule(it))?.getRoots() ?: [] }
  layout(targetDirectory) {
    dir("lib") {
      (platformLibraries+pluginLibraries-modulePluginLibraries).each {
        layoutLibrary(it, "$targetDirectory/lib")
      }
      layoutRuntimeResources(runtimeResources, "$targetDirectory/lib")
    }
  }
})

private Set<JpsLibrary> getLibrariesFromDependencies(Collection<String> moduleNames) {
  moduleNames.collectMany {JpsJavaExtensionService.dependencies(findModule(it)).recursively().withoutSdk().withoutModuleSourceEntries().runtimeOnly().productionOnly().getLibraries()} as Set<JpsLibrary>
}

binding.setVariable("generateRuntimeModuleDescriptors", { String distRoot, LayoutInfo layoutInfo ->
  layoutInfo.modules.each { moduleName ->
    registerModuleDescriptor(findModule(moduleName), layoutInfo.getModulePaths(moduleName))
  }
  createRuntimeModuleDescriptorGenerator().generateForProductionMode(new File(distRoot), getOrCreateRuntimeModuleDescriptorsList())
})

binding.setVariable("registerPluginFileNamesCompatibilityMap", { Map<String, Map<String, String>> namesMap ->
  getOrCreateFileNameCompatibilityMap().putAll(namesMap)
})

private Map<String, JpsLibrary> getOrCreateLibraryMap() {
  def variableName = "libraryByRuntimeId"
  if (!binding.hasVariable(variableName)) {
    def map = new HashMap<String, JpsLibrary>()
    project.libraryCollection.libraries.each {
      map[getLibraryId(it).stringId] = it
    }
    project.modules.each { module ->
      module.libraryCollection.libraries.each {
        map[getLibraryId(it).stringId] = it
      }
    }
    binding.setVariable(variableName, map)
  }
  return (Map<String,JpsLibrary>)binding.getVariable(variableName)
}

private void layoutInSubdir(List<Pair<JpsModule, String>> modulesWithScopes, List<Pair<JpsLibrary, String>> librariesWithScopes,
                            String outputPath, String scope, String subDirName) {
  def modules = modulesWithScopes.findAll { it.second == scope }.collect { it.first }
  def libraries = librariesWithScopes.findAll { it.second == scope }.collect { it.first }
  if (!modules.isEmpty() || !libraries.isEmpty()) {
    dir(subDirName) {
      modules.each { jpsModule ->
        jar("${jpsModule.name}.jar") {
          module(jpsModule.name)
        }
//        registerModuleDescriptor(jpsModule, ["$outputPath/$subDirName/${jpsModule.name}.jar"])
      }
      libraries.each { lib ->
        layoutLibrary(lib, "$outputPath/$subDirName")
      }
    }
  }
}

private void layoutLibrary(JpsLibrary lib, String outputPath) {
  def files = lib.getFiles(JpsOrderRootType.COMPILED)
  files.each {
    ant.fileset(file: it.absolutePath)
  }

  registerModuleDescriptor(getLibraryId(lib), files.collect { "$outputPath/$it.name" })
}


private List<File> toFiles(Collection<? extends CharSequence> paths) {
  paths.collect { new File(it.toString()) }
}

private def resources(Collection<String> modules) {
  jar("resources_en.jar") {
    modules.each {
      module(it) {
        patternset(refid: "resources.included")
      }
    }
  }
}

private def noResources(String moduleName) {
  module(moduleName) {
    patternset(refid: "resources.excluded")
  }
}

private File findPluginXml(JpsModule module) {
  for (root in module.sourceRoots) {
    if (JavaModuleSourceRootTypes.PRODUCTION.contains(root.getRootType())) {
      String prefix = root.getRootType() == JavaSourceRootType.SOURCE ?
                      root.asTyped(JavaSourceRootType.SOURCE).getProperties().getPackagePrefix().replace('.', '/')
                                                                      :
                      root.asTyped(JavaResourceRootType.RESOURCE).getProperties().getRelativeOutputPath()
      File pluginXml = new File(root.getFile(), StringUtil.trimStart(StringUtil.trimStart("META-INF/plugin.xml", prefix), "/"))
      if (pluginXml.isFile()) {
        return pluginXml
      }
    }
  }
  projectBuilder.error("plugin.xml file not found in '${module.getName()}'")
  return null
}

