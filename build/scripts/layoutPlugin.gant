/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import com.intellij.openapi.util.JDOMUtil
import com.intellij.openapi.util.Pair
import com.intellij.openapi.util.text.StringUtil
import org.jetbrains.jps.devkit.model.JpsRuntimeResourcesService
import org.jetbrains.jps.model.java.JavaModuleSourceRootTypes
import org.jetbrains.jps.model.java.JavaResourceRootType
import org.jetbrains.jps.model.java.JavaSourceRootType
import org.jetbrains.jps.model.library.JpsLibrary
import org.jetbrains.jps.model.library.JpsOrderRootType
import org.jetbrains.jps.model.module.JpsModule
import org.jetbrains.jps.util.JpsPathUtil

binding.setVariable("layoutPluginByRuntimeModules", { String mainModuleName ->
  def mainModule = findModule(mainModuleName)
  if (mainModule == null) {
    projectBuilder.error("Module '$mainModuleName' not found")
  }
  def pluginXml = findPluginXml(mainModule)
  def rootTag = JDOMUtil.load(pluginXml)
  List<Pair<String, String>> modulesWithScopes = []
  def libraryMap = getOrCreateLibraryMap()
  List<Pair<List<File>, String>> librariesWithScopes = []
  rootTag.getChildren("modules").each {
    it.getChildren("module").each {
      def moduleName = it.getTextTrim()
      def scope = it.getAttributeValue("scope") ?: moduleName == mainModuleName ? "embedded" : "IDE"
      if (!moduleName.startsWith("lib.")) {
        modulesWithScopes.add(Pair.create(moduleName, scope))
      }
      else {
        def library = libraryMap[moduleName]
        if (library == null) {
          projectBuilder.error("Cannot find library ${moduleName} required to build '$mainModuleName' plugin")
        }
        librariesWithScopes.add(Pair.create(library.getFiles(JpsOrderRootType.COMPILED), scope))
      }
    }
  }
  if (!modulesWithScopes.any { it.first == mainModuleName }) {
    modulesWithScopes.add(Pair.create(mainModuleName, "embedded"))
  }

  List<Pair<String, File>> runtimeResources = modulesWithScopes.collectMany {getRuntimeResources(findModule(it.first))}

  def compatibilityMap = getOrCreateFileNameCompatibilityMap()[mainModuleName]
  String mainJarName = compatibilityMap?.jar ?: "${mainModuleName}.jar"
  def dirName = compatibilityMap?.dir ?: mainModuleName

  dir(dirName) {
    dir("lib") {
      def embeddedModules = modulesWithScopes.findAll { it.second == "embedded" }.collect { it.first }
      jar(mainJarName) {
        embeddedModules.each {
          noResources(it)
        }
        librariesWithScopes.findAll {it.second == "embedded"}.collectMany {it.first}.each { File file ->
          zipfileset(src: file.absolutePath)
        }
      }

      def ideModules = modulesWithScopes.findAll { it.second.contains("IDE") }.collect { it.first }
      ideModules.each { String moduleName ->
        jar([name: "${moduleName}.jar", filesetmanifest: "merge"]) {
          noResources(moduleName)
        }
      }
      resources(ideModules + embeddedModules)
      librariesWithScopes.findAll {it.second.contains("IDE")}.collectMany {it.first}.each { File file ->
        fileset(file: file.absolutePath)
      }
      layoutInSubdir(modulesWithScopes, librariesWithScopes, "build", "jps")
      layoutInSubdir(modulesWithScopes, librariesWithScopes, "runtime", "rt")
    }
    if (!runtimeResources.isEmpty()) {
      dir("res") {
        runtimeResources.each { pair ->
          File file = pair.second
          if (file.isFile()) {
            fileset(file: file.absolutePath)
          }
          else if (file.isDirectory()) {
            dir(pair.first) {
              fileset(dir: file.absolutePath)
            }
          }
        }
      }
    }
  }
})

private Map<String, Map<String, String>> getOrCreateFileNameCompatibilityMap() {
  String varName = "fileNameCompatibilityMap"
  if (!binding.hasVariable(varName)) {
    binding.setVariable(varName, new HashMap())
  }
  return (Map<String, Map<String, String>>) binding.getVariable(varName)
}

binding.setVariable("registerPluginFileNamesCompatibilityMap", { Map<String, Map<String, String>> namesMap ->
  getOrCreateFileNameCompatibilityMap().putAll(namesMap)
})

private Map<String, JpsLibrary> getOrCreateLibraryMap() {
  def variableName = "libraryByRuntimeId"
  if (!binding.hasVariable(variableName)) {
    def map = new HashMap<String, JpsLibrary>()
    project.libraryCollection.libraries.each {
      map["lib.${it.getName()}"] = it
    }
    project.modules.each { module ->
      module.libraryCollection.libraries.each {
        map[getRuntimeName(module, it)] = it
      }
    }
    binding.setVariable(variableName, map)
  }
  return (Map<String,JpsLibrary>)binding.getVariable(variableName)
}

//duplicates code in RuntimeModuleDescriptorsGenerator.getLibraryId
private String getRuntimeName(JpsModule module, JpsLibrary library) {
  def files = library.getFiles(JpsOrderRootType.COMPILED)
  String libraryName = library.getName()
  if (files.size() == 1 && libraryName.startsWith("#")) {
    libraryName = files[0].name
  }
  return "lib.${module.name}.$libraryName"
}

private void layoutInSubdir(List<Pair<String, String>> modulesWithScopes, List<Pair<List<File>, String>> librariesWithScopes, String scope, String subDirName) {
  def modules = modulesWithScopes.findAll { it.second == scope }.collect { it.first }
  def libraries = librariesWithScopes.findAll { it.second == scope }.collectMany { it.first }
  if (!modules.isEmpty() || !libraries.isEmpty()) {
    dir(subDirName) {
      modules.each { String moduleName ->
        jar("${moduleName}.jar") {
          module(moduleName)
        }
      }
      libraries.each { File file ->
        fileset(file: file.absolutePath)
      }
    }
  }
}

private def resources(Collection<String> modules) {
  jar("resources_en.jar") {
    modules.each {
      module(it) {
        patternset(refid: "resources.included")
      }
    }
  }
}

private def noResources(String moduleName) {
  module(moduleName) {
    patternset(refid: "resources.excluded")
  }
}

private File findPluginXml(JpsModule module) {
  for (root in module.sourceRoots) {
    if (JavaModuleSourceRootTypes.PRODUCTION.contains(root.getRootType())) {
      String prefix = root.getRootType() == JavaSourceRootType.SOURCE ?
                      root.asTyped(JavaSourceRootType.SOURCE).getProperties().getPackagePrefix().replace('.', '/')
                                                                      :
                      root.asTyped(JavaResourceRootType.RESOURCE).getProperties().getRelativeOutputPath()
      File pluginXml = new File(root.getFile(), StringUtil.trimStart(StringUtil.trimStart("META-INF/plugin.xml", prefix), "/"))
      if (pluginXml.isFile()) {
        return pluginXml
      }
    }
  }
  projectBuilder.error("plugin.xml file not found in '${module.getName()}'")
  return null
}

private List<Pair<String, File>> getRuntimeResources(JpsModule module) {
  return JpsRuntimeResourcesService.instance.getRoots(module)?.getRoots()?.collect {Pair.create(it.name, JpsPathUtil.urlToFile(it.url))} ?: []
}