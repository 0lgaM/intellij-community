// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.intellij.plugins.markdown.lang.psi.impl

import com.intellij.lang.ASTNode
import com.intellij.navigation.ColoredItemPresentation
import com.intellij.navigation.ItemPresentation
import com.intellij.openapi.editor.colors.TextAttributesKey
import com.intellij.openapi.util.registry.Registry
import com.intellij.openapi.util.text.StringUtil
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiElementVisitor
import com.intellij.psi.util.elementType
import org.intellij.plugins.markdown.lang.MarkdownTokenTypeSets
import org.intellij.plugins.markdown.lang.psi.MarkdownElementVisitor
import org.intellij.plugins.markdown.lang.stubs.impl.MarkdownHeaderStubElement
import org.intellij.plugins.markdown.lang.stubs.impl.MarkdownHeaderStubElementType
import org.intellij.plugins.markdown.structureView.MarkdownStructureColors
import org.intellij.plugins.markdown.util.children
import org.intellij.plugins.markdown.util.hasType
import javax.swing.Icon

@Suppress("DEPRECATION")
class MarkdownHeader: MarkdownHeaderImpl {
  constructor(node: ASTNode): super(node)
  constructor(stub: MarkdownHeaderStubElement, type: MarkdownHeaderStubElementType): super(stub, type)

  val level
    get() = calculateHeaderLevel()

  /**
   * Anchor reference to this header.
   * Should be compatible with anchors generated by GitHub.
   *
   * ```markdown
   * # Some header text -> #some-header-text
   * ```
   * Exception: multiple headers with same text won't be adjusted with it's occurence number.
   */
  val anchorText: String?
    get() = buildAnchorText()

  override fun accept(visitor: PsiElementVisitor) {
    @Suppress("DEPRECATION")
    when (visitor) {
      is MarkdownElementVisitor -> visitor.visitHeader(this)
      else -> super.accept(visitor)
    }
  }

  override fun getPresentation(): ItemPresentation {
    val headerText = getHeaderText()
    val text = headerText ?: "Invalid header: $text"
    return object: ColoredItemPresentation {
      override fun getPresentableText(): String {
        val prevSibling = prevSibling
        if (Registry.`is`("markdown.structure.view.list.visibility") && MarkdownTokenTypeSets.LIST_MARKERS.contains(prevSibling.elementType)) {
          return prevSibling.text + text
        }
        return text
      }

      override fun getIcon(open: Boolean): Icon? = null

      override fun getTextAttributesKey(): TextAttributesKey? {
        return when (level) {
          1 -> MarkdownStructureColors.MARKDOWN_HEADER_BOLD
          else -> MarkdownStructureColors.MARKDOWN_HEADER
        }
      }
    }
  }

  override fun getName(): String? {
    return getHeaderText()
  }

  private fun findContentHolder(): PsiElement? {
    return findChildByType(MarkdownTokenTypeSets.INLINE_HOLDING_ELEMENT_TYPES)
  }

  private fun getHeaderText(): String? {
    if (!isValid) {
      return null
    }
    val contentHolder = findContentHolder() ?: return null
    return StringUtil.trim(contentHolder.text)
  }

  private fun buildAnchorText(): String? {
    val contentHolder = findContentHolder() ?: return null
    val children = contentHolder.children().filter { !it.hasType(MarkdownTokenTypeSets.WHITE_SPACES) }
    val text = buildString {
      append("#")
      var count = 0
      for (child in children) {
        if (count >= 1) {
          append(" ")
        }
        when (child) {
          is MarkdownImage -> append("")
          is MarkdownInlineLink -> processInlineLink(child)
          else -> append(child.text)
        }
        count += 1
      }
    }
    return text.lowercase().replace(garbageRegex, "").replace(" ", "-")
  }

  private fun StringBuilder.processInlineLink(element: MarkdownInlineLink) {
    val contentElements = element.linkText?.contentElements.orEmpty()
    val withoutWhitespaces = contentElements.filterNot { it.hasType(MarkdownTokenTypeSets.WHITE_SPACES) }
    withoutWhitespaces.joinTo(this, separator = " ") {
      when (it) {
        is MarkdownImage -> ""
        else -> it.text
      }
    }
  }

  companion object {
    private val garbageRegex = Regex("[^#\\w\\- ]")
  }
}
