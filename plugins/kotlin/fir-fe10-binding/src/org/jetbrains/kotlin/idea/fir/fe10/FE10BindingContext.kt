// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

package org.jetbrains.kotlin.idea.fir.fe10

import com.intellij.openapi.project.Project
import org.jetbrains.kotlin.analysis.api.KtAnalysisSession
import org.jetbrains.kotlin.analysis.api.fir.utils.EntityWasGarbageCollectedException
import org.jetbrains.kotlin.analysis.api.fir.utils.KtAnalysisSessionFe10BindingHolder
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeTokenFactory
import org.jetbrains.kotlin.analysis.api.lifetime.assertIsValidAndAccessible
import org.jetbrains.kotlin.analysis.api.symbols.*
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.getFirResolveSession
import org.jetbrains.kotlin.analysis.project.structure.KtModule
import org.jetbrains.kotlin.analysis.project.structure.getKtModule
import org.jetbrains.kotlin.analysis.providers.createProjectWideOutOfBlockModificationTracker
import org.jetbrains.kotlin.idea.base.util.Frontend10ApiUsage
import org.jetbrains.kotlin.builtins.DefaultBuiltIns
import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.fir.FirElement
import org.jetbrains.kotlin.idea.fir.analysis.project.structure.moduleInfo
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.psi.KtElement
import java.lang.ref.WeakReference

interface FE10BindingContext {
    val builtIns: KotlinBuiltIns
    val ktAnalysisSessionFacade: KtAnalysisSessionFe10BindingHolder
    val moduleDescriptor: ModuleDescriptor

    // This property used to disable some logic used locally for debug purposes
    val enableLogging: Boolean get() = false

    /**
     * Legend:
     *  - where was decided, that KtSymbolBased descriptor is not support method, noImplementation() method is called.
     *  - where the implementation planned, but not yet here: implementationPlanned()
     *  - if there is no simple implementation and it isn't clear if it really needed -- implementationPostponed()
     *  - if there were no investigation -- autogenerated TODO("not implemented") called
     *  - if we could implement it right now, but not entirely correct -- wrap it into incorrect implementation
     */
    fun noImplementation(additionalInfo: String = ""): Nothing
    fun implementationPostponed(additionalInfo: String = ""): Nothing
    fun implementationPlanned(additionalInfo: String = ""): Nothing

    fun <R> incorrectImplementation(block: () -> R) = block()
}

fun KtSymbol.toDeclarationDescriptor(context: FE10BindingContext): DeclarationDescriptor =
    when (this) {
        is KtNamedClassOrObjectSymbol -> KtSymbolBasedClassDescriptor(this, context)
        is KtFunctionLikeSymbol -> toDeclarationDescriptor(context)
        is KtValueParameterSymbol -> {
            val containingSymbol = context.withAnalysisSession { this@toDeclarationDescriptor.getContainingSymbol() }
            check(containingSymbol is KtFunctionLikeSymbol) {
                "Unexpected containing symbol = $containingSymbol"
            }
            KtSymbolBasedValueParameterDescriptor(this, context, containingSymbol.toDeclarationDescriptor(context))
        }
        else -> context.implementationPlanned()
    }

fun KtFunctionLikeSymbol.toDeclarationDescriptor(context: FE10BindingContext): KtSymbolBasedFunctionLikeDescriptor =
    when (this) {
        is KtFunctionSymbol -> KtSymbolBasedFunctionDescriptor(this, context)
        is KtAnonymousFunctionSymbol -> KtSymbolBasedAnonymousFunctionDescriptor(this, context)
        is KtConstructorSymbol -> {
            val ktConstructorSymbol = this
            val ktClassOrObject = context.withAnalysisSession { ktConstructorSymbol.getContainingSymbol() as KtNamedClassOrObjectSymbol }
            KtSymbolBasedConstructorDescriptor(ktConstructorSymbol, KtSymbolBasedClassDescriptor(ktClassOrObject, context))
        }
        else -> error("Unexpected kind of KtFunctionLikeSymbol: ${this.javaClass}")
    }

inline fun <R> FE10BindingContext.withAnalysisSession(f: KtAnalysisSession.() -> R): R = f(ktAnalysisSessionFacade.analysisSession)

class FE10BindingContextImpl(
    val project: Project,
    val ktElement: KtElement
) : FE10BindingContext {
    private val token: KtLifetimeToken = KtLifetimeTokenForKtSymbolBasedWrappers(project)

    private val module: KtModule = ktElement.getKtModule(project)

    override val ktAnalysisSessionFacade = KtAnalysisSessionFe10BindingHolder.create(module.getFirResolveSession(project), token, ktElement)

    override val moduleDescriptor: ModuleDescriptor = KtSymbolBasedModuleDescriptorImpl(this, module)

    override val builtIns: KotlinBuiltIns
        get() = incorrectImplementation { DefaultBuiltIns.Instance }

    override fun noImplementation(additionalInfo: String): Nothing =
        error("This method should not be called for wrappers. $additionalInfo")

    override fun implementationPostponed(additionalInfo: String): Nothing =
        TODO("InvestigateLater and implement if needed. $additionalInfo")

    override fun implementationPlanned(additionalInfo: String): Nothing =
        TODO("SE_to_implement. $additionalInfo")
}

private class KtLifetimeTokenForKtSymbolBasedWrappers(val project: Project) : KtLifetimeToken() {
    private val modificationTracker = project.createProjectWideOutOfBlockModificationTracker()
    private val onCreatedTimeStamp = modificationTracker.modificationCount

    override fun isValid(): Boolean {
        return true
    }

    override fun getInvalidationReason(): String {
        if (onCreatedTimeStamp != modificationTracker.modificationCount) return "PSI has changed since creation"
        error("Getting invalidation reason for valid validity token")
    }

    override fun isAccessible(): Boolean = true

    override fun getInaccessibilityReason(): String = error("Getting inaccessibility reason for validity token when it is accessible")

    override val factory = KtLifetimeTokenForKtSymbolBasedWrappersFactory
}

private object KtLifetimeTokenForKtSymbolBasedWrappersFactory : KtLifetimeTokenFactory() {
    override val identifier= KtLifetimeTokenForKtSymbolBasedWrappers::class

    override fun create(project: Project): KtLifetimeTokenForKtSymbolBasedWrappers =
        KtLifetimeTokenForKtSymbolBasedWrappers(project)
}

// This class supposed to be used for non-declaration resolved fir elements, because of that we don't case about FIR phases.
// TODO: review FIR access -- by common IDEA FIR design access FIR should be under read lock
internal class FirWeakReference<out T : FirElement>(firElement: T, private val token: KtLifetimeToken) {
    private val firWeakRef = WeakReference(firElement)

    inline fun <R> withFir(action: (T) -> R): R {
        return action(getFir())
    }

    fun getFir(): T {
        token.assertIsValidAndAccessible()
        return firWeakRef.get() ?: throw EntityWasGarbageCollectedException("FirElement")
    }
}

private class KtSymbolBasedModuleDescriptorImpl(
    val context: FE10BindingContext,
    val module: KtModule,
) : ModuleDescriptor {
    override val builtIns: KotlinBuiltIns
        get() = context.builtIns

    override val stableName: Name
        get() = context.noImplementation()
    override val platform: TargetPlatform
        get() = module.platform

    override fun shouldSeeInternalsOf(targetModule: ModuleDescriptor): Boolean = context.noImplementation()
    override fun getPackage(fqName: FqName): PackageViewDescriptor = context.noImplementation()
    override fun getSubPackagesOf(fqName: FqName, nameFilter: (Name) -> Boolean): Collection<FqName> = context.noImplementation()

    override val allDependencyModules: List<ModuleDescriptor>
        get() = context.implementationPostponed()
    override val expectedByModules: List<ModuleDescriptor>
        get() = context.implementationPostponed()
    override val allExpectedByModules: Set<ModuleDescriptor>
        get() = context.implementationPostponed()

    override fun <T> getCapability(capability: ModuleCapability<T>): T? = null

    override val isValid: Boolean
        get() = context.ktAnalysisSessionFacade.analysisSession.token.isValid()

    override fun assertValid() {
        assert(context.ktAnalysisSessionFacade.analysisSession.token.isValid())
    }

    @OptIn(Frontend10ApiUsage::class)
    override fun getName(): Name = module.moduleInfo.name

    override fun getOriginal(): DeclarationDescriptor = this

    override fun acceptVoid(visitor: DeclarationDescriptorVisitor<Void, Void>?) = context.noImplementation()

    override val annotations: Annotations
        get() = context.incorrectImplementation { Annotations.EMPTY }

}