jvm.inspections.group.name=JVM languages
jvm.inspections.test.frameworks.group.name=Test frameworks

jvm.inspections.unstable.api.usage.display.name=Unstable API Usage
jvm.inspections.unstable.api.usage.annotations.list=Unstable API annotations:
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignore inside imports
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignore API declared in this project
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=Overridden method ''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Overridden method ''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' is unstable because its signature references unstable {1} ''{2}'' marked with @{3}

jvm.inspections.scheduled.for.removal.future.version=a future version
jvm.inspections.scheduled.for.removal.predefined.version=version {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=Overridden method ''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=Overridden method ''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' is scheduled for removal because its signature references {1} ''{2}'' scheduled for removal in {3}

jvm.inspections.unstable.type.used.in.signature.display.name=Unstable type is used in signature
jvm.inspections.unstable.type.used.in.class.signature.description=Class must be marked with ''@{0}'' annotation because its declaration references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=Method must be marked with ''@{0}'' annotation because its signature references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=Field must be marked with ''@{0}'' annotation because its type references unstable type ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Missing '@Deprecated' annotation on scheduled for removal API
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Scheduled for removal API must also be marked with '@Deprecated' annotation
jvm.inspections.must.already.be.removed.api.display.name=API must already be removed
jvm.inspections.must.already.be.removed.api.earlier.version.description=API must have been removed in version {0} but the current version is {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API must be removed in the current version {0}
jvm.inspections.blocking.method.problem.descriptor=Possibly blocking call in non-blocking context could lead to thread starvation
jvm.inspections.blocking.method.problem.wildcard.descriptor=Possibly blocking call in {0} could lead to thread starvation
jvm.inspections.blocking.method.display.name=Possibly blocking call in non-blocking context
jvm.inspections.blocking.method.annotation.blocking=Blocking Annotations
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking Annotations
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Add blocking annotation
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Add non-blocking annotation
jvm.inspections.blocking.method.annotation.configure.empty.text=No annotations added.
jvm.inspections.blocking.method.consider.unknown.context.blocking=Consider unknown contexts blocking

jvm.inspections.api.no.extension.display.name=Class, interface, or method should not be extended
jvm.inspections.api.no.extension.class.description=Class ''{0}'' must not be extended
jvm.inspections.api.no.extension.interface.implement.description=Interface ''{0}'' must not be implemented
jvm.inspections.api.no.extension.interface.extend.description=Interface ''{0}'' must not be extended
jvm.inspections.api.no.extension.method.overriding.description=Method ''{0}'' must not be overridden
jvm.inspections.api.override.only.display.name=Method can only be overridden
jvm.inspections.api.override.only.description=Method ''{0}'' can only be overridden

jvm.inspections.dependency.display.name=Illegal package dependencies
jvm.inspections.dependency.edit.rules.text=Edit dependency rule \"{0} \"
jvm.inspections.dependency.edit.rules.family=Edit dependency rules
jvm.inspections.dependency.configure.button.text=Configure dependency rules
jvm.inspections.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated

jvm.inspections.dependency.on.internal.display.name=Illegal dependency on internal package
inspection.message.illegal.dependency.module.doesn.t.export=Illegal dependency: module ''{0}'' doesn''t export package ''{1}''

jvm.inspections.junit.datapoint.display.name=Malformed '@DataPoint' field
jvm.inspections.junit.datapoint.problem.descriptor={0}s annotated with ''{1}'' should be {2}

jvm.inspections.junit.rule.display.name=Malformed @Rule/@ClassRule field
jvm.inspections.junit.rule.problem.field.descriptor=Fields annotated with ''@{0}'' should be {1}
jvm.inspections.junit.rule.type.problem.field.descriptor=Field type should be subtype of ''{0}''
jvm.inspections.junit.class.rule.type.problem.field.descriptor=Field type should be subtype of ''{0}'' or ''{1}''
jvm.inspections.junit.rule.problem.method.descriptor=Methods annotated with ''@{0}'' should be {1}
jvm.inspections.junit.rule.type.problem.method.descriptor=Method return type should be subtype of ''{0}''
jvm.inspections.junit.class.rule.type.problem.method.descriptor=Method return type should be subtype of ''{0}'' or ''{1}''

jvm.inspections.source.to.sink.flow.display.name=Non-safe string is passed to safe method
jvm.inspections.source.to.sink.flow.passed.unsafe=Unsafe string is used as safe parameter
jvm.inspections.source.to.sink.flow.passed.unknown=Unknown string is used as safe parameter
jvm.inspections.source.to.sink.flow.returned.unsafe=Unsafe string is returned from safe method
jvm.inspections.source.to.sink.flow.returned.unknown=Unknown string is returned from safe method
jvm.inspections.source.to.sink.flow.assigned.unsafe=Unsafe string is assigned to safe variable
jvm.inspections.source.to.sink.flow.assigned.unknown=Unknown string is assigned to safe variable
jvm.inspections.source.to.sink.flow.common.unsafe=Unsafe string is used in a safe context
jvm.inspections.source.to.sink.flow.common.unknown=Unknown string is used in a safe context
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Mark as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Mark ''{0}'' as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Mark as Requiring Validation
jvm.inspections.source.unsafe.to.sink.flow.preview.multiple.files=Add '@Untainted' annotation in {0}
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Propagate safe annotation
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Propagate safe annotation from ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Select Members to Annotate as Safe
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Annotate All except Excluded
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Unsafe flow
propagated.from=Reason to mark as safe:
propagated.to=Target to mark as safe:
propagate.from.empty.text=Reason to mark as safe is shown here
propagate.to.empty.text=Target to mark as safe is shown here

jvm.inspections.testonly.display.name=Test-only usage in production code
jvm.inspections.testonly.class.reference=Test-only class is referenced in production code
jvm.inspections.testonly.field.reference=Test-only field is referenced in production code
jvm.inspections.testonly.method.call=Test-only method is called in production code
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting makes little sense on @TestOnly code

jvm.inspections.junit5.converter.display.name=JUnit 4 test can be JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref can be JUnit 5 test
jvm.inspections.junit5.converter.quickfix=Migrate to JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=Convert Assertions
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=Class {0} can''t be converted to JUnit 5, cause there are incompatible inheritor(s): {1}

jvm.inspections.junit5.nested.test.display.name=JUnit 5 malformed '@Nested' class
jvm.inspections.junit5.malformed.nested.class.inspection.description=Only non-static nested classes can serve as '@Nested' test classes.

jvm.inspections.junit5.extensions.display.name=JUnit 5 malformed extension registration
jvm.inspections.junit5.malformed.extension.registration.message={0} should implement {1}
jvm.inspections.junit5.malformed.extension.class.level.message={0} should be registered at the class level, otherwise beforeAll/afterAll methods won''t be executed

jvm.inspections.junit5.malformed.repeated.test.display.name=JUnit 5 malformed repeated test
jvm.inspections.junit5.malformed.repetition.description.injected.for.test=RepetitionInfo won't be injected for @Test methods
jvm.inspections.junit5.malformed.repetition.description.injected.for.each=RepetitionInfo is injected for @BeforeEach/@AfterEach only, but not for {0}
jvm.inspections.junit5.malformed.repetition.description.injected.for.repeatedtest=RepetitionInfo is injected for @RepeatedTest only
jvm.inspections.junit5.malformed.repetition.description.positive.number=The number of repetitions must be greater than zero
jvm.inspections.junit5.malformed.repetition.description.suspicious.combination=Suspicious combination @Test and @RepeatedTest

jvm.inspections.junit5.malformed.parameterized.display.name=Junit 5 malformed parameterized tests
jvm.inspections.junit5.malformed.parameterized.inspection.description.method.source.unresolved=Cannot resolve target method source: ''{0}''
jvm.inspections.junit5.malformed.parameterized.inspection.description.wrapped.in.arguments=Multiple parameters have to be wrapped in 'Arguments'
jvm.inspections.junit5.malformed.parameterized.inspection.description.method.source.return.type=Method source ''{0}'' must have one of the following return types: ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' or ''Object[]''
jvm.inspections.junit5.malformed.parameterized.inspection.description.method.source.no.params=Method source ''{0}'' should have no parameters
jvm.inspections.junit5.malformed.parameterized.inspection.description.method.source.static=Method source ''{0}'' must be static
jvm.inspections.junit5.malformed.parameterized.inspection.description.method.source.assignable=No implicit conversion found to convert ''{0}'' type to ''{1}'' type
jvm.inspections.junit5.malformed.parameterized.inspection.description.duplicated.enum=Duplicate 'enum' constant name
jvm.inspections.junit5.malformed.parameterized.inspection.description.unresolved.enum=Can't resolve 'enum' constant reference.
jvm.inspections.junit5.malformed.parameterized.inspection.description.no.value.source.is.defined=No value source is defined
jvm.inspections.junit5.malformed.parameterized.inspection.description.exactly.one.type.of.input.must.be.provided=Exactly one type of input must be provided
jvm.inspections.junit5.malformed.parameterized.inspection.description.file.source=Cannot resolve file source: ''{0}''
jvm.inspections.junit5.malformed.parameterized.inspection.description.nullsource.cannot.provide.argument.no.params=''@{0}'' cannot provide an argument to method because method doesn''t have parameters
jvm.inspections.junit5.malformed.parameterized.inspection.description.nullsource.cannot.provide.argument.too.many.params=''@{0}'' cannot provide an argument to method because method provides too many parameters
jvm.inspections.junit5.malformed.parameterized.inspection.description.emptysource.cannot.provide.argument=''@{0}'' cannot provide an argument to method because method has an unsupported parameter of ''{1}'' type
jvm.inspections.junit5.malformed.parameterized.fix.text=Change to ''{0}''
jvm.inspections.junit5.malformed.parameterized.inspection.description.suspicious.combination.test.and.parameterizedtest=Suspicious combination '@Test' and '@ParameterizedTest'
jvm.inspections.junit5.malformed.parameterized.inspection.description.suspicious.combination=Suspicious combination '@Test' and parameterized source
jvm.inspections.junit5.malformed.parameterized.inspection.description.multiple.parameters.are.not.supported.by.this.source=Multiple parameters are not supported by this source
jvm.inspections.junit5.malformed.parameterized.inspection.description.no.sources.are.provided=No sources are provided, the suite would be empty
jvm.inspections.junit5.malformed.parameterized.fix.family.name=Replace annotation

jvm.inspections.before.after.display.name=Malformed '@Before' or '@After' method
jvm.inspections.before.after.descriptor=<code>#ref()</code> has incorrect signature for a ''@{0}'' method #loc

jvm.inspections.before.after.class.display.name=Malformed '@BeforeClass'/'@BeforeAll' or '@AfterClass'/'@AfterAll' method

jvm.inspections.junit5.assertions.converter.display.name=JUnit 5 obsolete assertions
jvm.inspections.junit5.assertions.converter.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with a call to a method from ''{1}'' #loc
jvm.inspections.junit5.assertions.converter.quickfix=Replace with ''{0}'' method call
jvm.inspections.junit5.assertions.converter.familyName=Replace with JUnit 5 compatible call

jvm.inspections.unconstructable.test.case.display.name=Unconstructable JUnit test class
jvm.inspections.unconstructable.test.case.not.public.descriptor=Test class <code>#ref</code> is not constructable because it is not 'public' #loc
jvm.inspections.unconstructable.test.case.junit3.descriptor=Test class <code>#ref</code> is not constructable because it does not have a 'public' no-arg or single 'String' parameter constructor #loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=Test class <code>#ref</code> is not constructable because it should have exactly one 'public' no-arg constructor #loc


jvm.inspection.test.failed.line.display.name=Failed line in test

jvm.inspections.thread.run.display.name=Call to 'Thread.run()'

jvm.inspections.serializable.class.without.serialversionuid.display.name=Serializable class without 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> does not define a 'serialVersionUID' field #loc

jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code>String.{0}()</code> called without specifying a Locale using internationalized strings #loc

jvm.inspections.api.display.name=Usages of API which isn't available at the configured language level
assertequals.between.inconvertible.types.display.name='assertEquals()' between objects of inconvertible types
jvm.inspections.1.5.problem.descriptor=Usage of API documented as @since {0}+
jvm.inspections.1.7.problem.descriptor=Usage of generified after 1.6 API which would cause compilation problems with JDK {0}
jvm.inspections.1.8.problem.descriptor=Default {0, choice, 0#|1#method is|2# methods are} not overridden. It would cause compilation problems with JDK {1}
jvm.inspections.1.8.problem.single.descriptor=Default method ''{0}'' is not overridden. It would cause compilation problems with JDK {1}

jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Redundant assertion: incompatible types are compared ''{0}'' and ''{1}''
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Possible redundant assertion: incompatible types are compared ''{0}'' and ''{1}''

jvm.fix.make.no.arg.void.name=Fix method signature
jvm.fix.make.no.arg.void.descriptor=Fix ''{0}'' method signature

can.t.build.uast.tree.for.file=Can't build UAST tree for file
title.uast=UAST
current.version=Current version
dialog.title.choose.annotation=Choose {0}