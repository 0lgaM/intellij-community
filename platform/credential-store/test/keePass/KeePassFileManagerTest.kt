// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.credentialStore.keePass

import com.intellij.credentialStore.CredentialAttributes
import com.intellij.credentialStore.Credentials
import com.intellij.credentialStore.KeePassCredentialStore
import com.intellij.credentialStore.kdbx.KdbxPassword
import com.intellij.credentialStore.kdbx.KeePassDatabase
import com.intellij.credentialStore.kdbx.loadKdbx
import com.intellij.testFramework.assertions.Assertions.assertThat
import com.intellij.testFramework.rules.InMemoryFsRule
import com.intellij.util.Base64
import com.intellij.util.io.*
import org.junit.Rule
import org.junit.Test
import java.awt.Component
import java.nio.file.Path

private val testCredentialAttributes = CredentialAttributes("foo", "u")

internal class KeePassFileManagerTest {
  @JvmField
  @Rule
  val fsRule = InMemoryFsRule()

  private fun createTestStoreWithCustomMasterKey(baseDir: Path = fsRule.fs.getPath("/")): KeePassCredentialStore {
    val store = createStore(baseDir)
    store.set(testCredentialAttributes, Credentials("u", "p"))
    store.setMasterKey("foo")
    return store
  }

  @Test
  fun clear() {
    val store = createTestStoreWithCustomMasterKey()
    val dbFile = store.dbFile
    TestKeePassFileManager(store).clear()
    assertThat(dbFile).exists()
    assertThat(store.masterKeyFile).exists()
    assertThat(KeePassCredentialStore(store.dbFile, store.masterKeyFile).get(testCredentialAttributes)).isNull()
  }

  @Test
  fun `clear and remove if master password file doesn't exist`() {
    val store = createTestStoreWithCustomMasterKey()
    store.masterKeyFile.delete()
    val dbFile = store.dbFile
    TestKeePassFileManager(store).clear()
    assertThat(dbFile).doesNotExist()
    assertThat(store.masterKeyFile).doesNotExist()
  }

  @Test
  fun `clear and remove if master password file with incorrect master password`() {
    val store = createTestStoreWithCustomMasterKey()

    val oldMasterPasswordFile = store.masterKeyFile.parent.resolve("old.pwd")
    store.masterKeyFile.copy(oldMasterPasswordFile)
    store.setMasterKey("boo")
    oldMasterPasswordFile.copy(store.masterKeyFile)

    val dbFile = store.dbFile
    TestKeePassFileManager(store).clear()
    assertThat(dbFile).doesNotExist()
    assertThat(store.masterKeyFile).exists()
  }

  @Test
  fun `set master password - new database`() {
    TestKeePassFileManager(createStore(), masterPasswordRequestAnswer = "boo")
      .askAndSetMasterKey(event = null)

    val store = createStore()
    assertThat(store.dbFile).exists()
    assertThat(store.masterKeyFile.readText()).startsWith("""
      encryption: ${getDefaultEncryptionType().name}
      isAutoGenerated: false
      value: !!binary
    """.trimIndent())
    assertThat(MasterKeyFileStorage(store.masterKeyFile).get()!!.toString(Charsets.UTF_8)).isEqualTo("boo")
  }

  @Test
  fun `set master password - existing database with the same master password but incorrect master key file`() {
    TestKeePassFileManager(createTestStoreWithCustomMasterKey(), masterPasswordRequestAnswer = "foo")
      .askAndSetMasterKey(event = null)

    val store = createStore()
    assertThat(store.dbFile).exists()
    assertThat(MasterKeyFileStorage(store.masterKeyFile).get()!!.toString(Charsets.UTF_8)).isEqualTo("foo")
  }

  @Test
  fun `set master password - existing database with the different master password and incorrect master key file`() {
    val existingStore = createTestStoreWithCustomMasterKey()
    fsRule.fs.getPath("/$MASTER_KEY_FILE_NAME").delete()
    TestKeePassFileManager(existingStore, oldMasterPasswordRequestAnswer = "foo", masterPasswordRequestAnswer = "new")
      .askAndSetMasterKey(event = null)

    val store = createStore()
    assertThat(store.dbFile).exists()
    assertThat(store.masterKeyFile).exists()
  }

  @Test
  fun `import with custom master key located under imported file dir`() {
    val otherStore = createTestStoreWithCustomMasterKey(fsRule.fs.getPath("/other"))
    otherStore.save()

    val store = createStore()
    TestKeePassFileManager(store).import(otherStore.dbFile, event = null)

    checkStoreAfterSuccessfulImport(store)
  }

  private fun checkStoreAfterSuccessfulImport(store: KeePassCredentialStore) {
    store.reload()

    assertThat(store.dbFile).exists()
    assertThat(store.masterKeyFile).exists()

    assertThat(store.get(testCredentialAttributes)!!.getPasswordAsString()).isEqualTo("p")
  }

  @Test
  fun `import with custom master key but key file doesn't exist`() {
    val otherStore = createTestStoreWithCustomMasterKey(fsRule.fs.getPath("/other"))
    otherStore.save()
    fsRule.fs.getPath("/other/${MASTER_KEY_FILE_NAME}").move(fsRule.fs.getPath("/other/otherKey"))

    val store = createStore()
    val keePassFileManager = TestKeePassFileManager(store)
    keePassFileManager.import(otherStore.dbFile, event = null)
    assertThat(keePassFileManager.isUnsatisfiedMasterPasswordRequest).isTrue()
    assertThat(store.dbFile).doesNotExist()
    assertThat(store.masterKeyFile).doesNotExist()

    // assert that other store not corrupted
    fsRule.fs.getPath("/other/otherKey").move(fsRule.fs.getPath("/other/${MASTER_KEY_FILE_NAME}"))
    otherStore.reload()
    assertThat(otherStore.get(testCredentialAttributes)!!.getPasswordAsString()).isEqualTo("p")
  }

  @Test
  fun `import with custom master key but key file doesn't exist but user provided new`() {
    val otherStore = createTestStoreWithCustomMasterKey(fsRule.fs.getPath("/other"))
    otherStore.save()
    fsRule.fs.getPath("/other/${MASTER_KEY_FILE_NAME}").delete()

    val store = createStore()
    val keePassFileManager = TestKeePassFileManager(store, masterPasswordRequestAnswer = "foo")
    keePassFileManager.import(otherStore.dbFile, event = null)
    assertThat(keePassFileManager.isUnsatisfiedMasterPasswordRequest).isFalse()
    checkStoreAfterSuccessfulImport(store)
  }

  @Test
  fun reuseExisting() {
    val dbFile = fsRule.fs.getPath("/existingDb.kdbx")
    @Suppress("SpellCheckingInspection")
    dbFile.write(Base64.decode("A9mimmf7S7UBAAMAAhAAMcHy5r9xQ1C+WAUhavxa/wMEAAEAAAAEIAAWuDmigh57N8BZgj1w0GctkaqFTO7nPOroO5AnmUliFgUgAHCRnuiXHvLqSv2oJPMHI5QS9Ony+oIOww4kHcpz2wmEBggAcBcAAAAAAAAHEAB2bInsMKh/zNzzBaegBa/kCCAAw3NSQcu+oGXwJvY9Ht6NSCC19uGFN+sEP9n9E3tNCvoJIADD/kYwUqnCSzrzYXu3tcJcvBKzTinwcSZQ769wYZ/oPwoEAAIAAAAABAAA0K0KdKTDfpMiRxKSe1xkvCDuBDdlDe/hiU3YnkhhCZk48sB9OV4uZI1LPJAgQ8HogjxMjAhnNThYdjlFQ9TTfsb3wUXH/7IK8n69a8IoWuRp9fnchQFnnArXcZeimeUREb/3jcwTXrIHGg+AN7MPQCD/b47us2h07oaAVvGFLCaLU111mJNZrdjNvO9BKODUbqfFFVhJhMAazjsdVpRfV3dbm0apdgluJQ8eUFzrF4YZUUkenG869o/yngD2cm1BxmG2QZe2fel/PSWRRFZ0i6zJm3h9CnYStnDL2N6lm9MPqOm3pKUk0uOG8p9P4U4UHMOnwIFw4RReO5wnqpMN4DFUCfM1qqx0fuqc/sy3DEgpRg3ENsHU7AbidobJzIqGOeK9ywU6Rp5peJrLjbIszedVWVPvxwt/xgAHcaqfntV86XcG8MlJElLSsK4fh9gspySNeyP43wnLjAdFGHq5OtAkhTTwXzHSZTxhazTjClssAHYAyTEQrlYRFl4+4apzdq5g3crGl1vR0Ekj22ytIsQXu9HYVTZ6pk6ESQAIg1qieDZQl4B1eEaRNnyvkfhgPIUDLuG4ULMGm/L1dur2nhHlooqgR8gHo5MNclghOKZdOhJNOvsd7/1XDsziizOqbocjJtBCEOWSgI1Ht1fbmG1nO9C6MrzkkxK+xQaXZDG2fmitUw2flN3OMky/RJgMD4LVdZLoaHj3uq86USXjDc0ql7lHeRRmOhIJ3X8DZObJmyhlylBGYwmYB/PmOuoe28iM8/wQ4Xr8bSYco5kxOK8Bii5TotDXqhVlTdajCo5NN33nqeSc/f+5BGL/CmdxannLel1bnEJrY2ESYXrjzUSM0pgnJlLNxZYynw/XMtSPbXI8/m2ciAP9iXv5efJMOv8O6dmzlbiYz7efSEpIDiwHG7HAIVnVzmy26jhyHXchaQpouPnwj/QhzTL1lRv0qA2K5+wNIexkKQa4G4iZhSHVzZTHY12rpnLDTxWv2GXHCvwdY5AD6jTJazimlTpbVOf+UvDIPiY2ksmhnaZU9Lc/ItkInhtZwW0e0XtdcgunaVr5BvHTRRancrtRN23VAUlNzQ7Uror55JG3PxUThOX8XRmqJxMnIlgpNbv/tgqbks7zuCESLFjz0EM19QygatS+uHCWnsUp8sWl14bcrwGRoFsdPj/AFRGAv2xYwfMT8VBOZx1KpQ0vqxOx8t67pxpBUaH/Cqlh8Jje7vxXT7wrXQK3bVjpk2uYncAkd7ruk0y7X/Jzvyu9cfoEDn6EMOS0b5aE6VoywNHhbo3dGyZq3K25jOGvgLzRSj9ETBNL8DTccaNzkcyXBsj/gqUZ1rYxVZHPaJWi2Cgy07b+jV5FSRSMYkjNG90ADHKnqyuEG1Y7+pvIX1hOBGIVJ0HA9Ij6xYTZXkGRu6V+WGYEPnDJ4Pi+EYwD400nxtrxwpGiEHWYzyjACHB2BKS9J3BDh4S/"))

    fun checkEntry(db: KeePassDatabase) {
      assertThat(db.rootGroup.getEntry("foo", "foo")!!.password!!.get().toString()).isEqualTo("bar")
    }

    val kdbxPassword = KdbxPassword("foo".toByteArray())
    var db = loadKdbx(dbFile, kdbxPassword)
    checkEntry(db)

    dbFile.outputStream().use {
      db.save(kdbxPassword, it)
    }

    db = loadKdbx(dbFile, kdbxPassword)
    checkEntry(db)
  }

  private fun createStore() = createStore(fsRule.fs.getPath("/"))
}

internal fun KeePassCredentialStore.setMasterKey(value: String) = setMasterPassword(MasterKey(value.toByteArray(), isAutoGenerated = false))

@Suppress("TestFunctionName")
private class TestKeePassFileManager(store: KeePassCredentialStore,
                                     private val masterPasswordRequestAnswer: String? = null,
                                     private val oldMasterPasswordRequestAnswer: String? = null) : KeePassFileManager(store.dbFile, store.masterKeyFile) {
  var isUnsatisfiedMasterPasswordRequest = false

  override fun requestMasterPassword(title: String, contextComponent: Component?, ok: (value: ByteArray) -> String?): Boolean {
    if (masterPasswordRequestAnswer == null) {
      isUnsatisfiedMasterPasswordRequest = true
      return false
    }
    else {
      assertThat(ok(masterPasswordRequestAnswer.toByteArray())).isNull()
      return true
    }
  }

  override fun requestCurrentAndNewKeys(contextComponent: Component?): Boolean {
    doSetNewMasterPassword(oldMasterPasswordRequestAnswer!!.toCharArray(), masterPasswordRequestAnswer!!.toCharArray())
    return true
  }
}