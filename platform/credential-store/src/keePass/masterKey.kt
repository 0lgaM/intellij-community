// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.credentialStore.keePass

import com.intellij.credentialStore.LOG
import com.intellij.credentialStore.windows.WindowsCryptUtils
import com.intellij.openapi.util.SystemInfo
import com.intellij.openapi.util.io.BufferExposingByteArrayOutputStream
import com.intellij.openapi.util.io.setOwnerPermissions
import com.intellij.util.EncryptionSupport
import com.intellij.util.io.delete
import com.intellij.util.io.readBytes
import com.intellij.util.io.writeSafe
import org.yaml.snakeyaml.composer.Composer
import org.yaml.snakeyaml.nodes.MappingNode
import org.yaml.snakeyaml.nodes.NodeId
import org.yaml.snakeyaml.nodes.ScalarNode
import org.yaml.snakeyaml.nodes.Tag
import org.yaml.snakeyaml.parser.ParserImpl
import org.yaml.snakeyaml.reader.StreamReader
import org.yaml.snakeyaml.resolver.Resolver
import java.nio.file.NoSuchFileException
import java.nio.file.Path
import java.security.Key
import java.util.*
import javax.crypto.spec.SecretKeySpec

internal const val MASTER_KEY_FILE_NAME = "c.pwd"
private const val OLD_MASTER_PASSWORD_FILE_NAME = "pdb.pwd"

private class WindowsEncryptionSupport(key: Key): EncryptionSupport(key) {
  override fun encrypt(data: ByteArray, size: Int): ByteArray = WindowsCryptUtils.protect(super.encrypt(data, size))

  override fun decrypt(data: ByteArray): ByteArray = super.decrypt(WindowsCryptUtils.unprotect(data))
}

internal enum class EncryptionType {
  BUILT_IN, CRYPT_32
}

internal class MasterKey(value: ByteArray,
                         // is password auto-generated, used to force set master password if database file location changed
                         val isAutoGenerated: Boolean,
                         val encryption: EncryptionType = getDefaultEncryptionType()) {
  var value: ByteArray? = value

  /**
   * Clear byte array to avoid sensitive data in memory
   */
  fun clear() {
    Arrays.fill(value!!, 0)
    value = null
  }
}

internal fun getDefaultEncryptionType() = if (SystemInfo.isWindows) EncryptionType.CRYPT_32 else EncryptionType.BUILT_IN

internal class MasterKeyFileStorage(private val passwordFile: Path) {
  companion object {
    private val builtInEncryptionKey = SecretKeySpec(byteArrayOf(
      0x50, 0x72, 0x6f.toByte(), 0x78.toByte(), 0x79.toByte(), 0x20.toByte(),
      0x43.toByte(), 0x6f.toByte(), 0x6e.toByte(), 0x66.toByte(), 0x69.toByte(), 0x67.toByte(),
      0x20.toByte(), 0x53.toByte(), 0x65.toByte(), 0x63.toByte()), "AES")

    private fun createEncryptionSupport(encryptionType: EncryptionType): EncryptionSupport {
      return when (encryptionType) {
        EncryptionType.BUILT_IN -> EncryptionSupport(builtInEncryptionKey)
        EncryptionType.CRYPT_32 -> {
          if (!SystemInfo.isWindows) {
            throw IllegalArgumentException("Crypt32 encryption is supported only on Windows")
          }
          WindowsEncryptionSupport(builtInEncryptionKey)
        }
      }
    }
  }

  private var encryptionType = getDefaultEncryptionType()

  fun get(): ByteArray? {
    var data: ByteArray
    var isOld = false
    try {
      data = passwordFile.readBytes()
    }
    catch (e: NoSuchFileException) {
      try {
        data = passwordFile.parent.resolve(OLD_MASTER_PASSWORD_FILE_NAME).readBytes()
      }
      catch (e: NoSuchFileException) {
        return null
      }
      isOld = true
    }

    try {
      val masterKey: MasterKey
      if (isOld) {
        masterKey = MasterKey(data, true, getDefaultEncryptionType())
      }
      else {
        masterKey = readMasterKey(data) ?: return null
      }

      encryptionType = masterKey.encryption
      val decrypted = createEncryptionSupport(masterKey.encryption).decrypt(masterKey.value!!)
      masterKey.clear()
      return decrypted
    }
    catch (e: Exception) {
      LOG.warn("Cannot decrypt master key, file content:\n${if (isOld) Base64.getEncoder().encodeToString(data) else data.toString(Charsets.UTF_8)}", e)
      return null
    }
  }

  private fun readMasterKey(data: ByteArray): MasterKey? {
    val composer = Composer(ParserImpl(StreamReader(data.inputStream().reader())), object : Resolver() {
      override fun resolve(kind: NodeId, value: String?, implicit: Boolean): Tag {
        return when (kind) {
          NodeId.scalar -> Tag.STR
          else -> super.resolve(kind, value, implicit)
        }
      }
    })

    var encryptionType: EncryptionType? = null
    var value: ByteArray? = null
    var isAutoGenerated = true
    val list = (composer.singleNode as? MappingNode)?.value ?: emptyList()
    for (node in list) {
      val keyNode = node.keyNode
      val valueNode = node.valueNode
      if (keyNode is ScalarNode && valueNode is ScalarNode) {
        val propertyValue = valueNode.value ?: continue
        when (keyNode.value) {
          "encryption" -> encryptionType = EncryptionType.valueOf(propertyValue.toUpperCase())
          "isAutoGenerated" -> isAutoGenerated = propertyValue.toBoolean() || propertyValue == "yes"
          "value" -> value = Base64.getDecoder().decode(propertyValue)
        }
      }
    }

    if (encryptionType == null) {
      LOG.error("encryption type not specified in $passwordFile, default one will be used (file content:\n${data.toString(Charsets.UTF_8)})")
      encryptionType = getDefaultEncryptionType()
    }
    if (value == null) {
      LOG.error("password not specified in $passwordFile, automatically generated will be used (file content:\n${data.toString(Charsets.UTF_8)})")
      return null
    }

    return MasterKey(value, isAutoGenerated = isAutoGenerated, encryption = encryptionType)
  }

  fun set(key: MasterKey?) {
    if (key == null) {
      passwordFile.delete()
      return
    }

    val out = BufferExposingByteArrayOutputStream()
    val encryptionType = key.encryption
    out.writer().use {
      it.append("encryption: ").append(encryptionType.name).append('\n')
      it.append("isAutoGenerated: ").append(key.isAutoGenerated.toString()).append('\n')
      it.append("value: !!binary ")
    }
    out.write(Base64.getEncoder().encode(createEncryptionSupport(encryptionType).encrypt(key.value!!)))

    key.clear()

    passwordFile.writeSafe(out.internalBuffer, 0, out.size())
    passwordFile.setOwnerPermissions()
  }

  fun isAutoGenerated(): Boolean {
    try {
      val key = readMasterKey(passwordFile.readBytes()) ?: return false
      key.clear()
      return key.isAutoGenerated
    }
    catch (e: NoSuchFileException) {
      // true because on save will be generated
      return true
    }
  }
}